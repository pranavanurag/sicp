# chapter 1 exercises

## 1.1

```scheme
10
12
8
3
6
a
b
19
#f
4
16
6
16
```

## 1.2

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
```

## 1.3

```scheme
(define (sqr x) (* x x))

(define (sum-of-sqrs x y) (+ (sqr x) (sqr y)))

(define (sos-larger-2 x y z)
    (cond ((and (< x y) (< x z)) (sum-of-sqrs y z))
            ((and (< y z) (< y x)) (sum-of-sqrs x z))
            (else (sum-of-sqrs x y))))
```

## 1.4

```scheme
(define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))

#|
required operation is: (a + abs(b))
this is equivalent to:
if (b > 0), a + b
else a - b

the given implementation decides whether to use the + or the - operator based on whether b is greater than 0
|#
```

## 1.5

```scheme
(define (p) (p))
(define (test x y)
    (if (= x 0) 0 y))

#|
applicative-order-evaluation (evaluate, use):
    will result in an inf loop, since the self referencing procedure will attempt to evaluate itself

normal-order-evaluation (subsitute, then reduce):
    will return 0 since the predicate of the conditional will be evaluated
|#
```

## 1.6

new-if, being a compound procedure and not a special form, is computed in 2 steps

1. the formal parameters are evaluated as operands
2. the operation, in this case the compound procedure is applied on the operands

this implies that the else-clause passed to this procedure will have to be computed before it is dealt with inside the body of the compound procedure new-if

the special form if allows us to compute the predicate while avoiding the computation of the clauses

## 1.7

attempting to find the square root of a number smaller than the set tolerance threshold will clearly fail

a large number like 99118991284657502 with a tolerance threshold of 0.001 fails, due to the square of guesses not being precise enough for the method to converge

```scheme
(define (good-enough? x guess)
    (define fraction-tolerance 0.001)
    (define next-guess (improve-guess x guess))
    (define change (abs (- next-guess guess)))
    (< (/ change guess) fraction-tolerance))
```

this new definition works decently well for small numbers, however with large numbers the margin of error is similar to the old definition

this is because the calculation of the square of a large guess is not precise

## 1.8

```scheme
(define (improve-guess x guess) (/ (+ (* 2 guess) (/ x (sq guess))) 3))
```

everything else is identical to our impl for finding square roots

## 1.9

```scheme
(define (+ a b)
    (if (= a 0) b (inc (+ (dec a) b))))

#|
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc (5)))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
|#

(define (+ a b)
    (if (= a 0) b (+ (dec a) (inc b))))

#|
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
|#

#|
the first process is recursive in nature since the stack stores the number of times inc must be applied to the result of the + procedure

the second process is iterative since the state is stored completely in the formal parameters
|#
```

## 1.10

```scheme
(define (A x y)
    (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

#|
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
....
(A 0 (A 0 (A 0 (.... (A 0 1)))))
(A 0 (A 0 (A 0 (...... 2))))
2^10 = 1024
|#

#|
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 16)
2^16 = 65536
|#


#|
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1))
(A 2 (A 0 2))
(A 2 4)
already computed, 65536
|#

#|
(define (f n) (A 0 n)) = 2 * n

(define (g n) (A 1 n)) = 2 ^ n

(define (h n) (A 2 n)) = (A 1 (A 2 (-1+ n)))
                        = 2 ^ (h (n - 1))
```

## 1.11
```scheme
(define (compute-f x)
    (if (< x 3)
        x
        (compute-f-iter 2 1 0 (- x 2))
    )
)


(define (compute-f-iter p1 p2 p3 x)
    (if (= x 0)
        p1
        (compute-f-iter (compute-next p1 p2 p3) p1 p2 (- x 1))
    )
)

(define (compute-next p1 p2 p3)
    (+ p1 (+ (* 2 p2) (* 3 p3)))
)
```

## 1.12
```scheme
(define (ptr-element r c)
    (cond
        ((or (= c 0) (= r c)) 1)
        ((or (> c r) (or (< r 0) (< c 0))) -1)
        (else (+ (ptr-element (- r 1) (- c 1)) (ptr-element (- r 1) c)))
    )
)
```

## 1.13
```
prove fib(n) = closest integer to (phi^n / sqrt(5))
phi = (1 + sqrt(5)) / 2
psi = (1 - sqrt(5)) / 2

"clint" is "closest integer to"
"rt5" is "sqrt(5)"

hint: using induction, prove fib(n) = (phi^n - psi^n) / rt5

fib(0) = (phi^n - psi^n) / rt5 = 0
holds for n = 0

fib(n + 1) = fib(n) + fib(n - 1) by definition
assuming fib(n) = (phi^n - psi^n) / rt5 is true,

fib(n + 1) = ((phi^n - psi^n) / rt5) + ((phi^(n-1) - psi^(n-1)) / rt5)
fib(n + 1) = (phi^(n-1) * (1 + phi) - psi^(n-1) * (1 + psi)) / rt5

note that
    1 + phi = phi^2,
    1 + psi = psi^2

fib(n + 1) = (phi^(n+1) - psi^(n+1)) / rt5

therefore, fib(n) = (phi^n - psi^n) / rt5
psi = (1 - rt5) / 2 = approx. -0.6
phi = (1 + rt5) / 2 = approx. 1.6

let ffib = floor(phi^n / rt5)
let cfib = ceiling(phi^n / rt5)

fib(n) = ffib, if (phi^n / rt5) - ffib < cfib - (phi^n / rt5)
, cfib otherwise

todo
```