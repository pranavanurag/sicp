# chapter 1 exercises

## 1.1

```scheme
10
12
8
3
6
a
b
19
#f
4
16
6
16
```

## 1.2

```scheme
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
```

## 1.3

```scheme
(define (sqr x) (* x x))

(define (sum-of-sqrs x y) (+ (sqr x) (sqr y)))

(define (sos-larger-2 x y z)
    (cond ((and (< x y) (< x z)) (sum-of-sqrs y z))
            ((and (< y z) (< y x)) (sum-of-sqrs x z))
            (else (sum-of-sqrs x y))))
```

## 1.4

```scheme
(define (a-plus-abs-b a b)
    ((if (> b 0) + -) a b))

#|
required operation is: (a + abs(b))
this is equivalent to:
if (b > 0), a + b
else a - b

the given implementation decides whether to use the + or the - operator based on whether b is greater than 0
|#
```

## 1.5

```scheme
(define (p) (p))
(define (test x y)
    (if (= x 0) 0 y))

#|
applicative-order-evaluation (evaluate, use):
    will result in an inf loop, since the self referencing procedure will attempt to evaluate itself

normal-order-evaluation (subsitute, then reduce):
    will return 0 since the predicate of the conditional will be evaluated
|#
```

## 1.6

new-if, being a compound procedure and not a special form, is computed in 2 steps

1. the formal parameters are evaluated as operands
2. the operation, in this case the compound procedure is applied on the operands

this implies that the else-clause passed to this procedure will have to be computed before it is dealt with inside the body of the compound procedure new-if

the special form if allows us to compute the predicate while avoiding the computation of the clauses

## 1.7

attempting to find the square root of a number smaller than the set tolerance threshold will clearly fail

a large number like 99118991284657502 with a tolerance threshold of 0.001 fails, due to the square of guesses not being precise enough for the method to converge

```scheme
(define (good-enough? x guess)
    (define fraction-tolerance 0.001)
    (define next-guess (improve-guess x guess))
    (define change (abs (- next-guess guess)))
    (< (/ change guess) fraction-tolerance))
```

this new definition works decently well for small numbers, however with large numbers the margin of error is similar to the old definition

this is because the calculation of the square of a large guess is not precise

## 1.8

```scheme
(define (improve-guess x guess) (/ (+ (* 2 guess) (/ x (sq guess))) 3))
```

everything else is identical to our impl for finding square roots

## 1.9

```scheme
(define (+ a b)
    (if (= a 0) b (inc (+ (dec a) b))))

#|
(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc (5)))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
|#

(define (+ a b)
    (if (= a 0) b (+ (dec a) (inc b))))

#|
(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
|#

#|
the first process is recursive in nature since the stack stores the number of times inc must be applied to the result of the + procedure

the second process is iterative since the state is stored completely in the formal parameters
|#
```

## 1.10

```scheme
(define (A x y)
    (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1) (A x (- y 1))))))

#|
(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
....
(A 0 (A 0 (A 0 (.... (A 0 1)))))
(A 0 (A 0 (A 0 (...... 2))))
2^10 = 1024
|#

#|
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 16)
2^16 = 65536
|#


#|
(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 (A 1 (A 2 1))
(A 2 (A 1 2))
(A 2 (A 0 (A 1 1))
(A 2 (A 0 2))
(A 2 4)
already computed, 65536
|#

#|
(define (f n) (A 0 n)) = 2 * n

(define (g n) (A 1 n)) = 2 ^ n

(define (h n) (A 2 n)) = (A 1 (A 2 (-1+ n)))
                        = 2 ^ (h (n - 1))
```

## 1.11
```scheme
(define (compute-f x)
    (if (< x 3)
        x
        (compute-f-iter 2 1 0 (- x 2))
    )
)


(define (compute-f-iter p1 p2 p3 x)
    (if (= x 0)
        p1
        (compute-f-iter (compute-next p1 p2 p3) p1 p2 (- x 1))
    )
)

(define (compute-next p1 p2 p3)
    (+ p1 (+ (* 2 p2) (* 3 p3)))
)
```

## 1.12
```scheme
(define (ptr-element r c)
    (cond
        ((or (= c 0) (= r c)) 1)
        ((or (> c r) (or (< r 0) (< c 0))) -1)
        (else (+ (ptr-element (- r 1) (- c 1)) (ptr-element (- r 1) c)))
    )
)
```

## 1.13
```
prove fib(n) = closest integer to (phi^n / sqrt(5))
phi = (1 + sqrt(5)) / 2
psi = (1 - sqrt(5)) / 2

"rt5" is "sqrt(5)"

hint: using induction, prove fib(n) = (phi^n - psi^n) / rt5

fib(0) = (phi^n - psi^n) / rt5 = 0
holds for n = 0

fib(n + 1) = fib(n) + fib(n - 1) by definition
assuming fib(n) = (phi^n - psi^n) / rt5 is true,

fib(n + 1) = ((phi^n - psi^n) / rt5) + ((phi^(n-1) - psi^(n-1)) / rt5)
fib(n + 1) = (phi^(n-1) * (1 + phi) - psi^(n-1) * (1 + psi)) / rt5

note that
    1 + phi = phi^2,
    1 + psi = psi^2

fib(n + 1) = (phi^(n+1) - psi^(n+1)) / rt5

therefore, fib(n) = (phi^n - psi^n) / rt5
psi = (1 - rt5) / 2 = approx. -0.6
phi = (1 + rt5) / 2 = approx. 1.6

abs(psi) = 0.4 and psi^n -> 0 with increasing n
(fib(n) - phi^n / rt5) = psi^n / rt5 lies between -0.4 and +0.1

therefore, fib(n) is the closest integer to phi^n / rt5
```

## 1.14
```

```


## 1.15
```
a. 5 times
b. every call where x > 0.1, will trigger (sine (/ x 3))
    therefore, time and space will scale by log(x)
```


## 1.16
```scheme
(define (remainder dividend divisor)
  (let ((qoutient (floor (/ dividend divisor))))
	(- dividend (* divisor qoutient))))

(define (sq x) (* x x))

(define (even n) (= (remainder n 2) 0))

(define (fast-exp-recursive base power)
  (if (= power 0)
	  1
	  (if (even power)
		  (fast-exp-recursive (sq base) (/ power 2))
		  (* base (fast-exp-recursive (sq base) (/ (- power 1) 2)))
	  )
  )
)

(define (fast-exp-iter base power answer)
  (if (= power 0)
	  answer
	  (if (even power)
		  (fast-exp-iter (sq base) (/ power 2) answer)
		  (fast-exp-iter base (- power 1) (* answer base))
	  )
  )
)

(define (fast-exp base power)
  (fast-exp-iter base power 1))
```

## 1.17
```scheme
(define (remainder dividend divisor)
  (let ((qoutient (floor (/ dividend divisor))))
	(- dividend (* divisor qoutient))))

(define (double x) (+ x x))

(define (halve x) (/ x 2))

(define (even n) (= (remainder n 2) 0))

(define (multiply-successive-doubling a b)
    (if (= b 0)
	    0
        (if (even b)
            (multiply-successive-doubling (double a) (halve b))
            (+ a (multiply-successive-doubling a (- b 1)))
        )
    )
)
```

## 1.18
```scheme
;; keep a separate answer so you dont forget what you were meant to calculate in the original question
;; in recursion, state can just be the subproblem and the stack will remember what to do with the result of this subproblem
(define (multiply-successive-doubling-iter a b answer)
  (if (= b 0)
	  answer
	  (if (even b)
		  (multiply-successive-doubling-iter (double a) (halve b) answer)
		  (multiply-successive-doubling-iter a (- b 1) (+ a answer)))))
```

## 1.19
```scheme
(define (sq x) (* x x))

(define (fib n)
	(fib-iter 1 0 0 1 n))

(define (fib-iter a b p q count)
	(cond
		((= count 0) b)
		((even? count)
			(fib-iter a
				b
				(+ (sq p) (sq q))
				(+ (sq q) (* 2 (* q p)))
				(/ count 2)))
		(else (fib-iter (+ (* b q)
			(* a q)
			(* a p))
			(+ (* b p) (* a q))
			p
			q
			(- count 1)))))
```

## 1.20
```
(define (gcd a b)
    (if (= b 0)
        a
        (gcd b (remainder a b))))

;; 1. applicative order (operands are computed before applying procedures)
;; (gcd 206 40) since 40 != 0, (gcd 40 (remainder 206 40)) and is evaluated to (gcd 40 6)
;; (gcd 40 6) since 6 != 0, (gcd 6 (remainder 40 6)) and is evaluated to (gcd 6 4)
;; (gcd 6 4) since 4 != 0, (gcd 4 (remainder 6 4)) and is evaluated to (gcd 4 2)
;; (gcd 4 2) since 2 != 0, (gcd 2 (remainder 4 2)) and is evaluated to (gcd 2 0)
;; (gcd 2 0) since 0 = 0, 2 is the answer
;; 4 remainder operations are performed

;; 2. normal order (operands are computed when needed)
;; (gcd 206 40) since 40 != 0, (gcd 40 (remainder (206 40)))
;; (gcd 40 (remainder 206 40))
    -> is (remainder 206 40) equal to 0?  no, it equals 6 [1 operation]
    -> evaluate (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
;; (gcd (remainder 206 40) (remainder 40 (remainder 206 40)))
    -> is (remainder 40 (remainder 206 40)) equal to 0? no, it equals 4 [2 operations]
    -> evaluate (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;; (gcd (remainder 40 (remainder 206 40)) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
    -> is (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) equal to 0? no, it equals 2 [4 operations]
    -> evaluate (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
;; (gcd (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) (remainder (remainder 40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))))
    -> is (remainder (remainder 40 (remainder 206 40))) (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) equal to 0? yes! [7 operations]
    -> return (remainder (remainder 206 40) (remainder 40 (remainder 206 40))) [4 operations]
;; 18 remainder operations are performed
```

